folder
    e2e.test.js
    unit.test.js

cli
    node --test-runner folder

    cp

- async contexts ok
- parallelism ok
- reporter-tracker
    - error
    - success
- reporter-executor
// ℹ tests 2
// ℹ suites 2
// ℹ pass 2
// ℹ fail 0
// ℹ cancelled 0
// ℹ skipped 0
// ℹ todo 0
// ℹ duration_ms 54.868709


---

Talk plan

Node.js test runner
    - features
    - really fast
    - uses internal node.js algorithms and leverage the C++ power

Why recreating stuff ?
    ESLINT
    Uglify
    WebSocket
    Node.js
Now
    Node.js test runner

I'm part of the nodejs
    - implemented the first draft of mock timers

But whats a test runner ?
    1. CLI that receives a folder and executes files
    2. Module that can order and report errors

Test Suite: A collection of test cases grouped together, typically because they test related functionality.
describe
Test Case: An individual unit test that checks a specific functionality of the code.
it
Test Hierarchy:
Organizes tests into a tree-like structure, making it easier to manage and understand the relationship between tests.

A test runner is a crucial component in the software development process, designed to execute tests, manage test states, and report results. Here are the key components of a test runner:

### 1. Test Suite Management

**Test Suites and Test Cases:**
- **Test Suite**: A collection of test cases grouped together, typically because they test related functionality.
- **Test Case**: An individual unit test that checks a specific functionality of the code.

**Test Hierarchy:**
- Organizes tests into a tree-like structure, making it easier to manage and understand the relationship between tests.

### 2. Test Execution

**Execution Engine:**
- Manages the execution of test cases and suites.
- Handles the order in which tests are run, including setup and teardown procedures.

**Hooks:**
- **Before/After Hooks**: Code that runs before or after all tests in a suite.
- **BeforeEach/AfterEach Hooks**: Code that runs before or after each individual test case.

### 3. Test Isolation

**Async Context Management:**
- Ensures tests are run in isolated contexts, preventing side effects between tests.
- Manages asynchronous operations within tests to maintain isolation.

### 4. Result Reporting

**Event Emission:**
- Emits events at various stages of the test lifecycle (e.g., start, pass, fail, end).
- Allows for custom handling of these events, such as logging or reporting.

**Logging:**
- Captures and displays logs related to test execution.
- Provides detailed error messages and stack traces for failed tests.

**Summary Generation:**
- Aggregates and summarizes test results, providing a high-level overview of the test execution.
- Includes metrics such as the number of tests passed, failed, skipped, and the total execution time.



Pieces
    - test-runner - executor
    - formatter
    - reporter

Executor challenges
    - Must run data in parallel
    - Must know the call three
        - describe and it can be declared in any place and you should know the tree back
        - how?
    - Introducing Async Hooks
    - Introducing Async LocalStorage
        - show Web API Example
            - users are concurrent, we won't like to use global variables and store user's data across sessions
    - Creating the first demo
    - Running demo  - show demo on test-runner (creating test )

Reporters
    - Show how many reporters nodejs support
    - demo reporters
    - challenge
        = in parallel, so how do you sync them?
            bc it'd be slow right? like file 1 is setting data every 20ms and file 2 is sending every 10ms, so you'd hold all messages from file2 until file 2 is finished

            The only challenge is in printing the received messages from multiple files in order
    - Moshe Atlow:
        Well id say it's exactly what you expect from a test runner, doesn't do anything more than the essentials which is what makes it very fast

- Plus
    - What if we run a complete app on this?
    - demo







